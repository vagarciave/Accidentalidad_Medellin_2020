comparacion
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(2,3,1,3,1,2,2,1,3,1,2,3,3,1,2,3,1,2,3,1,2)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
y <- matrix(c(5, 4, 7, 6,
1, 2, 1, 2,
16, 18, 15, 17,
3, 4, 4, 6,
7, 12, 11, 8,
14, 14, 16, 15),
nrow = 6, byrow = TRUE,
dimnames = list(Tienda = as.character(1:6),
Marca = as.character(1:4)))
friedman.test(y)
T1 <- 5.5179
T2 <- round(((6-1)*T1)/(6*(4-1)-T1), 4)
T2
round(pf(q = T2, df1 = 4-1, df2 = (6-1)*(4-1), lower.tail = F), 4)
x <- c(19, 17, 22, 12, 13, 9, 11, 8, 6, 7, 10)
length(c)
length(x)
x <- c(19, 17, 22, 12, 13, 9, 11, 8, 6, 7, 10)
y <- c(rep(1, 5), rep(0, 6))
mod <- monot_reg(x, y)
mod
x <- c(19, 17, 22, 12, 13, 9, 11, 8, 6, 7, 10)
y <- c(rep(1, 5), rep(0, 6))
mod <- monot_reg(x, y)
mod
plot(y~x)
plot(y~x, las = 1)
datos <- data.frame(x, y)
datos[order(x),]
datos <- datos[order(x),]
x <- c(19, 17, 22, 12, 13, 9, 11, 8, 6, 7, 10)
y <- c(rep(1, 5), rep(0, 6))
datos <- data.frame(x, y)
datos <- datos[order(x),]
x <- datos$x
y <- datos$y
mod <- monot_reg(x, y)
mod
mean(c(1,2,3,4,5,6))
mean(c(7,8,9,10,11))
11*12**2
11*12**2/4
(1:6)*3.5
(7:11)*9
(1:11)**2
sum(c((1:6)*3.5, (7:11)*9))
sum((1:11)**2)
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = T)
1 - 0.15087
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,2,2,1,3,2,3,3,3,2,1,3,3,3,1,1,2,2,1,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
comparacion$rank
comparacion
T1
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T1
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
preferencia <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T1
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = T)
comparacion
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = T)
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
comparacion
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T1
pf(q = 0.025, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = T)
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T1
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
pf(q = 0.025, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
T1 <- 9
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
T2
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T2
pf(q = 2.4, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
pf(q = 3.6, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
list(T2 = T2, valor_critico = Valor.C)  # Si T2 es mayor a valor critico, se rechaza H0
comparacion
T2
pf(q = T2, df1 = t-1,  df2 = b*k-b-t+1, lower.tail = F)
b*k-b-t+1
persona <- gl(7,3) #gl:generate levels. Genera 3 niveles para los 7 bloques
variedad <- c(1,2,4,2,3,5,3,4,6,4,5,7,1,5,6,2,6,7,1,3,7)
preferencia <- c(1,2,3,1,2,3,3,2,1,1,3,2,2,3,1,3,2,1,2,3,1)
comparacion <- durbin.test(persona,variedad,preferencia,group=F,
main="Preferencias por 7 variedades de helado")
T1 <- comparacion$statistics[1]
t <- 7
k <- 3
b <- 7
r <- 3
lambda <- 1
T2 <- as.numeric((T1/(t-1))/((b*(k-1)-T1)/(b*k-b-t+1)))
Valor.C <- qf(p = 0.95, df1 = t-1, df2 = b*k-b-t+1, lower.tail = T)
knitr::opts_chunk$set(echo = TRUE)
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
library(tidyverse)
library(lme4)
bd1 <- datos %>% count(FECHA, COMUNA, CLASE)
str(bd1)
bd1$FECHA <- as.Date(bd1$FECHA)
mod1 <- glmer(n ~ FECHA,
data = bd1, family= poisson())
mod1 <- glmer(n ~ FECHA + (1|COMUNA),
data = bd1, family= poisson())
## Creación de covariables FECHA y t, en base a las otras covariables
datos$FECHA <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
library(tidyverse)
library(lme4)
library(dplyr)
library(magrittr)
library(ggplot2)
library(lubridate)
## Creación de covariables FECHA y t, en base a las otras covariables
datos$FECHA <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
library("zoo")
## Creación de covariables FECHA y t, en base a las otras covariables
datos$FECHA <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Modificación de MES a su nombre en inglés
datos$MES <- factor(months(datos$FECHA), levels =month.name[1:12])
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$t <- as.numeric(as.Date(datos$FECHA, frac=0.5)) - as.numeric(as.Date("2014-01-01"))
View(datos)
month.name
month.name[1:12]
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
months(datos$FECHA)
datos$FECHA <- as.Date(datos$FECHA)
months(datos$FECHA)
# Modificación de MES a su nombre en inglés
datos$MES <- factor(months(datos$FECHA), levels =month.name[1:12])
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
# Modificación de MES a su nombre en inglés
datos$MES_NOMBRE <- factor(months(datos$FECHA), levels =month.name[1:12])
datos$FECHA <- as.Date(datos$FECHA)
# Modificación de MES a su nombre en inglés
datos$MES_NOMBRE <- factor(months(datos$FECHA), levels =month.name[1:12])
## Creación de covariables FECHA y t, en base a las otras covariables
datos$FECHA2 <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
knitr::opts_chunk$set(echo = TRUE)
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
library(tidyverse)
library(lme4)
library(dplyr)
library(magrittr)
library(ggplot2)
library(lubridate)
library("zoo")
datos$FECHA <- as.Date(datos$FECHA)
## Creación de covariables FECHA y t, en base a las otras covariables
datos$FECHA2 <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Modificación de MES a su nombre en inglés
datos$MES_NOMBRE <- factor(months(datos$FECHA2), levels =month.name[1:12])
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$t <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01"))
knitr::opts_chunk$set(echo = TRUE)
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
library(tidyverse)
library(lme4)
library(dplyr)
library(magrittr)
library(ggplot2)
library(lubridate)
library("zoo")
datos$FECHA <- as.Date(datos$FECHA)
## Creación de covariables FECHA y t, en base a las otras covariables
datos$MES_NOMBRE <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$t <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01") + 1)
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$t <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01")) + 1
View(bd1)
View(datos)
mod1 <- glmer(n ~ t + (1|COMUNA),
data = bd1, family= poisson())
mod1 <- glmer(n ~ t + (1|COMUNA),
data = datos, family= poisson())
bd1 <- datos %>% count(MES_NOMBRE, COMUNA, CLASE)
str(bd1)
bd1$FECHA <- as.Date(bd1$FECHA)
bd1
bd1 <- datos %>% count(MES_NOMBRE, t, COMUNA, CLASE)
str(bd1)
bd1
bd1 <- datos %>% count(COMUNA, MES_NOMBRE, t, CLASE)
bd1
bd1 <- datos %>% count(COMUNA, MES_NOMBRE, t)
str(bd1)
bd1
mod1 <- glmer(n ~ t + (1|COMUNA),
data = datos, family= poisson())
mod1 <- glmer(n ~ t + (1|COMUNA),
data = bd1, family= poisson())
mod1 <- glmer(n ~ poly(t, 4) + (1|COMUNA),
data = bd1, family= poisson())
summary(mod1)
MSE <- function(y, y_est) mean((y-y_est)**2)
test <- datos[datos$PERIODO == 2018, ]
train <- -test
train <- datos[datos$PERIODO %in% c(2014, 2015, 2016, 2017), ]
dim(train)[1] + dim(test)[1]
test <- datos[datos$PERIODO == 2018, ]
train <- datos[datos$PERIODO %in% c(2014, 2015, 2016, 2017), ]
y_est <- predict(mod1, newdata = bd1, type = "response")
MSE(bd1$n, y_est)
y_est <- round(predict(mod1, newdata = bd1, type = "response"), 0)
MSE(bd1$n, y_est)
datos$FECHA <- sapply(datos$FECHA, function(x) substr(x,1,10))
datos <- datos %>%
mutate(FECHA = ymd(FECHA)) %>%
mutate(SEMANA_MES = isoweek(FECHA) - isoweek(ceiling_date(FECHA, "month") - months(1)) + 1,
DIA_FESTIVO = ifelse(ymd(FECHA) %in% festivos,1,0))
datos$FECHA <- sapply(datos$FECHA, function(x) substr(x,1,10))
datos <- datos %>%
mutate(FECHA = ymd(FECHA)) %>%
mutate(SEMANA_MES = isoweek(FECHA) - isoweek(ceiling_date(FECHA, "month") - months(1)) + 1)
View(datos)
setwd("C:/Users/Usuario/Desktop/NACHO/Semestre 8/TAE/Project_x/modelo")
base_completa <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
base_completa$FECHA <- sapply(base_completa$FECHA, function(x) substr(x,1,10))
base_completa <- base_completa %>%
mutate(FECHA = ymd(FECHA)) %>%
mutate(SEMANA_MES = isoweek(FECHA) - isoweek(ceiling_date(FECHA, "month") - months(1)) + 1)
write.csv(base_completa, "Base_definitiva.csv", fileEncoding = "UTF-8",
row.names = F)
View(base_completa)
knitr::opts_chunk$set(echo = TRUE)
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
library(tidyverse)
library(lme4)
library(dplyr)
library(magrittr)
library(ggplot2)
library(lubridate)
library("zoo")
datos$FECHA <- as.Date(datos$FECHA)
datos$MES_NOMBRE <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$t <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01")) + 1
datos$FECHA <- as.Date(datos$FECHA)
datos$MES_NOMBRE <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$TIEMPO <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01")) + 1
knitr::opts_chunk$set(echo = TRUE)
datos <- read.csv("Base_definitiva.csv", header = T, stringsAsFactors = T,
encoding = "UTF-8")
library(tidyverse)
library(lme4)
library(dplyr)
library(magrittr)
library(ggplot2)
library(lubridate)
library("zoo")
datos$FECHA <- as.Date(datos$FECHA)
datos$MES_NOMBRE <- paste(datos$PERIODO, datos$MES, sep="-") %>% as.yearmon("%Y-%m")
# Para obtener la inversa se usaría: zoo::as.Date(datos$FECHA, origin="2014-01-01")
datos$TIEMPO <- as.numeric(as.Date(datos$FECHA)) - as.numeric(as.Date("2014-01-01")) + 1
datos$N_ACCIDENTES <- 1
datos %>% spread(CLASE, N_ACCIDENTES, fill = 0)
datos <- datos %>% spread(CLASE, N_ACCIDENTES, fill = 0)
test <- datos[datos$PERIODO == 2018, ]
train <- datos[datos$PERIODO %in% c(2014, 2015, 2016, 2017), ]
bd1 <- datos %>% count(COMUNA, MES_NOMBRE, TIEMPO, Atropello)
bd1
View(train)
bd1 <- datos %>% count(COMUNA, MES_NOMBRE, TIEMPO, Atropello, `Caida Ocupante`,
Choque, Incendio, Otro, Volcamiento) %>%
mutate(N_ACCIDENTES = Atropello + `Caida Ocupante` + Choque + Incendio +
Otro + Volcamiento)
str(bd1)
bd1
bd1 <- datos %>% count(COMUNA, FECHA, TIEMPO, Atropello, `Caida Ocupante`,
Choque, Incendio, Otro, Volcamiento)
str(bd1)
bd1
mod1 <- glmer(n ~ poly(TIEMPO, 3) + (1|COMUNA),
data = bd1, family= poisson())
MSE <- function(y, y_est) mean((y-y_est)**2)
y_est <- round(predict(mod1, newdata = bd1, type = "response"), 0)
MSE(bd1$n, y_est)
bd1 <- datos %>% count(COMUNA, PERIODO, FECHA, TIEMPO, Atropello, `Caida Ocupante`,
Choque, Incendio, Otro, Volcamiento)
str(bd1)
bd1
test <- bd1[bd1$PERIODO == 2018, ]
train <- bd1[bd1$PERIODO %in% c(2014, 2015, 2016, 2017), ]
mod1 <- glmer(n ~ poly(TIEMPO, 3) + (1|COMUNA),
data = train, family= poisson())
MSE <- function(y, y_est) mean((y-y_est)**2)
y_est <- round(predict(mod1, newdata = bd1, type = "response"), 0)
MSE(test$n, y_est)
MSE <- function(y, y_est) mean((y-y_est)**2)
y_est <- round(predict(mod1, newdata = test, type = "response"), 0)
MSE(test$n, y_est)
data.frame(test$n, y_est)
mod1 <- glmer(n ~ poly(TIEMPO, 3) + (1 + poly(TIEMPO, 2)| COMUNA),
data = train, family= poisson())
MSE <- function(y, y_est) mean((y-y_est)**2)
y_est <- round(predict(mod1, newdata = test, type = "response"), 0)
MSE(test$n, y_est)
data.frame(test$n, y_est)
data.frame(test[,"COMUNA", "FECHA","n"], y_est)
data.frame(test[,"COMUNA", "FECHA","n"], y_est)
data.frame(test[,c("COMUNA", "FECHA","n")], y_est)
MSE(test$n, y_est)
data.frame(test[,c("COMUNA", "FECHA","n")], y_est)
data.frame(test[,c("COMUNA", "FECHA","n")], y_est)[1,]
v <- data.frame(test[,c("COMUNA", "FECHA","n")], y_est)
v[sample(1:nrow(v), 1000), ]
bd1 <- datos %>% count(COMUNA, PERIODO, FECHA, DIA_FESTIVO, TIEMPO, Atropello, `Caida Ocupante`,
Choque, Incendio, Otro, Volcamiento)
bd1
test <- bd1[bd1$PERIODO == 2018, ]
train <- bd1[bd1$PERIODO %in% c(2014, 2015, 2016, 2017), ]
mod1 <- glmer(n ~ poly(TIEMPO, 3) + DIA_FESTIVO + (1 + poly(TIEMPO, 2)| COMUNA),
data = train, family= poisson())
y_est <- round(predict(mod1, newdata = test, type = "response"), 0)
MSE(test$n, y_est)
v <- data.frame(test[,c("COMUNA", "FECHA","n")], y_est)
v[sample(1:nrow(v), 1000), ]
summary(mod1)
mod1 <- glmer(n ~ poly(TIEMPO, 1) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod2 <- glmer(n ~ poly(TIEMPO, 2) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod3 <- glmer(n ~ poly(TIEMPO, 3) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
anova(mod1, mod2, mod3)
mod0 <- glmer(n ~ poly(TIEMPO, 1) + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod1 <- glmer(n ~ poly(TIEMPO, 1) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod2 <- glmer(n ~ poly(TIEMPO, 2) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod3 <- glmer(n ~ poly(TIEMPO, 3) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
anova(mod0, mod1, mod2, mod3)
mod0 <- glmer(n ~ TIEMPO + (1 + TIEMPO| COMUNA),
data = train, family= poisson())
mod1 <- glmer(n ~ TIEMPO + DIA_FESTIVO + (1 + TIEMPO| COMUNA),
data = train, family= poisson())
mod2 <- glmer(n ~ poly(TIEMPO, 2) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
mod3 <- glmer(n ~ poly(TIEMPO, 3) + DIA_FESTIVO + (1 + poly(TIEMPO, 1)| COMUNA),
data = train, family= poisson())
anova(mod0, mod1, mod2, mod3)
?isSingular
